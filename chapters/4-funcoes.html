<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Capítulo 4: Declaração de funções, parâmetros nomeados/posicionais, closures, arrow functions</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="assets/css/style.css">
</head>
<body>
    <div class="chapter-header">
        <h1 class="chapter-title">Capítulo 4: Declaração de funções, parâmetros nomeados/posicionais, closures, arrow functions</h1>
        <p class="chapter-subtitle">Dominando funções em Dart para código modular e reutilizável</p>
    </div>

    <div class="chapter-content">
        <div class="chapter-objectives">
            <h2>Objetivos do Capítulo</h2>
            <ol class="objectives-list">
                <li>Compreender como declarar e usar funções em Dart</li>
                <li>Dominar parâmetros posicionais, nomeados e opcionais</li>
                <li>Entender o conceito de closures e sua aplicação prática</li>
                <li>Aplicar arrow functions para código mais conciso</li>
                <li>Implementar funções de alta ordem (higher-order functions)</li>
                <li>Reconhecer casos de uso reais no desenvolvimento</li>
            </ol>
        </div>

        <div class="prerequisites">
            <h2>Pré-requisitos</h2>
            <ul class="prereq-list">
                <li>Conhecimento básico de variáveis e tipos em Dart</li>
                <li>Familiaridade com operadores básicos</li>
                <li>Acesso ao DartPad (https://dartpad.dev) ou Dart SDK instalado localmente</li>
            </ul>
        </div>

        <section class="content-section">
            <h2>1. Fundamentos de Funções</h2>
            <p>Uma <strong>função</strong> é um bloco de código reutilizável que executa uma tarefa específica. Pense nela como uma "receita de bolo" - você define os ingredientes (parâmetros) e os passos (código), e pode usar essa receita quantas vezes quiser.</p>
            
            <p>Em Dart, toda função retorna um valor. Se você não especificar um retorno, a função retorna <code>null</code> automaticamente.</p>

            <div class="example">
                <h3>Exemplo 1 — Função Básica com Retorno</h3>
                <div class="dartpad-container">
                    <div class="dartpad-header">
                        <span>DartPad - Funções Básicas</span>
                        <div class="dartpad-actions">
                            <button class="run-button"><i class="fas fa-play"></i> Executar</button>
                            <button class="copy-button"><i class="fas fa-copy"></i> Copiar</button>
                        </div>
                    </div>
                    <div class="code-block">
                        <pre><code>void main() {
  // Chamando nossa função personalizada
  String resultado = saudar('Maria');
  print(resultado);
  
  // Chamando função que calcula
  int soma = somar(10, 5);
  print('A soma é: $soma');
}

// Função que retorna uma String
String saudar(String nome) {
  return 'Olá, $nome! Bem-vindo ao Dart.';
}

// Função que retorna um int
int somar(int a, int b) {
  return a + b;
}</code></pre>
                    </div>
                </div>
                <div class="example-explanation">
                    <p><strong>Explicação:</strong></p>
                    <ul>
                        <li><code>String saudar(String nome)</code> - declara uma função que recebe um parâmetro <code>nome</code> e retorna uma <code>String</code></li>
                        <li><code>return</code> - palavra-chave que especifica o valor retornado pela função</li>
                        <li><code>int somar(int a, int b)</code> - função que recebe dois inteiros e retorna a soma</li>
                        <li>As funções podem ser chamadas quantas vezes necessário</li>
                    </ul>
                    <p><strong>Experimente:</strong> Troque os valores passados para as funções e observe como os resultados mudam.</p>
                </div>
            </div>
        </section>

        <section class="content-section">
            <h2>2. Parâmetros Posicionais</h2>
            <p><strong>Parâmetros posicionais</strong> são aqueles cuja ordem importa na chamada da função. É como fazer um sanduíche - primeiro o pão, depois o recheio, depois o pão de novo.</p>

            <div class="example">
                <h3>Exemplo 2 — Parâmetros Posicionais Obrigatórios</h3>
                <div class="dartpad-container">
                    <div class="dartpad-header">
                        <span>DartPad - Parâmetros Posicionais</span>
                        <div class="dartpad-actions">
                            <button class="run-button"><i class="fas fa-play"></i> Executar</button>
                            <button class="copy-button"><i class="fas fa-copy"></i> Copiar</button>
                        </div>
                    </div>
                    <div class="code-block">
                        <pre><code>void main() {
  // Ordem dos parâmetros é importante
  String ficha = criarFicha('João', 'Silva', 25);
  print(ficha);
  
  // Calculando área de retângulo
  double area = calcularArea(5.0, 3.0);
  print('Área: ${area.toStringAsFixed(2)} m²');
  
  // Testando divisão
  try {
    double resultado = dividir(10.0, 0.0);
    print('Resultado: $resultado');
  } catch (e) {
    print('Erro: $e');
  }
}

String criarFicha(String nome, String sobrenome, int idade) {
  return 'Nome: $nome $sobrenome, Idade: $idade anos';
}

double calcularArea(double largura, double altura) {
  return largura * altura;
}

double dividir(double dividendo, double divisor) {
  if (divisor == 0) {
    throw ArgumentError('Não é possível dividir por zero!');
  }
  return dividendo / divisor;
}</code></pre>
                    </div>
                </div>
                <div class="example-explanation">
                    <p><strong>Explicação:</strong></p>
                    <ul>
                        <li>A ordem dos argumentos na chamada deve corresponder à ordem dos parâmetros na declaração</li>
                        <li><code>throw ArgumentError()</code> - lança uma exceção quando algo está errado</li>
                        <li><code>try/catch</code> - captura e trata erros que podem acontecer</li>
                    </ul>
                    <p><strong>Experimente:</strong> Troque a ordem dos parâmetros na chamada e veja o que acontece.</p>
                </div>
            </div>
        </section>

        <section class="content-section">
            <h2>3. Parâmetros Nomeados</h2>
            <p><strong>Parâmetros nomeados</strong> permitem especificar argumentos por nome, não por posição. É como pedir uma pizza - você pode dizer "quero calabresa com borda recheada" sem se preocupar com a ordem.</p>

            <div class="example">
                <h3>Exemplo 3 — Parâmetros Nomeados</h3>
                <div class="dartpad-container">
                    <div class="dartpad-header">
                        <span>DartPad - Parâmetros Nomeados</span>
                        <div class="dartpad-actions">
                            <button class="run-button"><i class="fas fa-play"></i> Executar</button>
                            <button class="copy-button"><i class="fas fa-copy"></i> Copiar</button>
                        </div>
                    </div>
                    <div class="code-block">
                        <pre><code>void main() {
  // Usando parâmetros nomeados - ordem não importa
  String perfil1 = criarPerfil(
    nome: 'Ana',
    idade: 30,
    profissao: 'Desenvolvedora',
    cidade: 'São Paulo'
  );
  
  String perfil2 = criarPerfil(
    profissao: 'Designer',
    nome: 'Carlos', 
    cidade: 'Rio de Janeiro',
    idade: 28
  );
  
  print(perfil1);
  print('---');
  print(perfil2);
  
  // Configurando uma conexão
  configurarConexao(
    host: 'localhost',
    porta: 8080,
    ssl: true,
    timeout: 5000
  );
}

String criarPerfil({
  required String nome,
  required int idade,
  required String profissao,
  required String cidade
}) {
  return '''
Perfil do Usuário:
- Nome: $nome
- Idade: $idade anos
- Profissão: $profissao
- Cidade: $cidade
''';
}

void configurarConexao({
  required String host,
  required int porta,
  bool ssl = false,
  int timeout = 3000
}) {
  print('Conectando em $host:$porta');
  print('SSL: ${ssl ? "Ativado" : "Desativado"}');
  print('Timeout: ${timeout}ms');
}</code></pre>
                    </div>
                </div>
                <div class="example-explanation">
                    <p><strong>Explicação:</strong></p>
                    <ul>
                        <li><code>{required String nome}</code> - chaves indicam parâmetros nomeados</li>
                        <li><code>required</code> - torna o parâmetro obrigatório</li>
                        <li><code>ssl = false</code> - valor padrão quando não especificado</li>
                        <li>A ordem dos argumentos na chamada não importa</li>
                        <li>Código fica mais legível e autodocumentado</li>
                    </ul>
                    <p><strong>Experimente:</strong> Remova o <code>required</code> de algum parâmetro e veja o que acontece.</p>
                </div>
            </div>
        </section>

        <section class="content-section">
            <h2>4. Parâmetros Opcionais e Valores Padrão</h2>
            <p>Parâmetros opcionais tornam funções mais flexíveis. É como um controle remoto - você pode usar só os botões básicos ou todos os recursos avançados.</p>

            <div class="example">
                <h3>Exemplo 4 — Parâmetros Opcionais Posicionais e Nomeados</h3>
                <div class="dartpad-container">
                    <div class="dartpad-header">
                        <span>DartPad - Parâmetros Opcionais</span>
                        <div class="dartpad-actions">
                            <button class="run-button"><i class="fas fa-play"></i> Executar</button>
                            <button class="copy-button"><i class="fas fa-copy"></i> Copiar</button>
                        </div>
                    </div>
                    <div class="code-block">
                        <pre><code>void main() {
  // Parâmetros opcionais posicionais
  print(formatarMoeda(100.50));
  print(formatarMoeda(100.50, 'USD'));
  print(formatarMoeda(100.50, 'EUR', 3));
  
  print('---');
  
  // Parâmetros opcionais nomeados
  enviarEmail(
    para: 'usuario@example.com',
    assunto: 'Bem-vindo!'
  );
  
  enviarEmail(
    para: 'cliente@empresa.com',
    assunto: 'Confirmação de Pedido',
    corpo: 'Seu pedido foi confirmado com sucesso!',
    prioridade: 'alta'
  );
  
  // Criando URLs flexíveis
  print(construirUrl('api.exemplo.com'));
  print(construirUrl('api.exemplo.com', porta: 8080));
  print(construirUrl('api.exemplo.com', ssl: false, porta: 3000));
}

// Parâmetros opcionais posicionais (entre colchetes)
String formatarMoeda(double valor, [String moeda = 'BRL', int decimais = 2]) {
  String simbolo = moeda == 'BRL' ? 'R\$' : 
                   moeda == 'USD' ? '\$' : 
                   moeda == 'EUR' ? '€' : moeda;
  
  return '$simbolo ${valor.toStringAsFixed(decimais)}';
}

// Parâmetros opcionais nomeados
void enviarEmail({
  required String para,
  required String assunto,
  String corpo = 'Mensagem vazia',
  String prioridade = 'normal'
}) {
  print('📧 Email enviado:');
  print('Para: $para');
  print('Assunto: $assunto');
  print('Corpo: $corpo');
  print('Prioridade: $prioridade');
  print('');
}

String construirUrl(String host, {bool ssl = true, int? porta}) {
  String protocolo = ssl ? 'https' : 'http';
  String portaStr = porta != null ? ':$porta' : '';
  
  return '$protocolo://$host$portaStr';
}</code></pre>
                    </div>
                </div>
                <div class="example-explanation">
                    <p><strong>Explicação:</strong></p>
                    <ul>
                        <li><code>[String moeda = 'BRL']</code> - parâmetros opcionais posicionais entre colchetes</li>
                        <li><code>{String corpo = 'Mensagem vazia'}</code> - parâmetros opcionais nomeados</li>
                        <li><code>int? porta</code> - parâmetro pode ser nulo (null-safe)</li>
                        <li>Valores padrão são usados quando argumentos não são fornecidos</li>
                    </ul>
                    <p><strong>Experimente:</strong> Chame as funções omitindo diferentes parâmetros opcionais.</p>
                </div>
            </div>
        </section>

        <section class="content-section">
            <h2>5. Arrow Functions</h2>
            <p><strong>Arrow functions</strong> (funções de seta) são uma forma concisa de escrever funções simples. É como usar uma calculadora básica ao invés de uma científica quando você só precisa somar.</p>

            <div class="example">
                <h3>Exemplo 5 — Arrow Functions</h3>
                <div class="dartpad-container">
                    <div class="dartpad-header">
                        <span>DartPad - Arrow Functions</span>
                        <div class="dartpad-actions">
                            <button class="run-button"><i class="fas fa-play"></i> Executar</button>
                            <button class="copy-button"><i class="fas fa-copy"></i> Copiar</button>
                        </div>
                    </div>
                    <div class="code-block">
                        <pre><code>void main() {
  // Testando arrow functions
  print('Dobro de 5: ${dobrar(5)}');
  print('É par? ${ehPar(4)}');
  print('Quadrado de 3: ${quadrado(3)}');
  
  // Lista de números para testar
  List<int> numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  
  // Usando arrow functions com métodos de lista
  var pares = numeros.where((n) => n % 2 == 0).toList();
  var dobrados = numeros.map((n) => n * 2).toList();
  var soma = numeros.reduce((a, b) => a + b);
  
  print('Números originais: $numeros');
  print('Apenas pares: $pares');
  print('Dobrados: $dobrados');
  print('Soma total: $soma');
  
  // Validações rápidas
  print('Nome válido: ${validarNome("João")}');
  print('Email válido: ${validarEmail("test@example.com")}');
  
  // Operações matemáticas
  print('Máximo entre 10 e 20: ${maximo(10, 20)}');
  print('Área do círculo (r=3): ${areaCirculo(3).toStringAsFixed(2)}');
}

// Arrow functions simples
int dobrar(int numero) => numero * 2;
bool ehPar(int numero) => numero % 2 == 0;
int quadrado(int numero) => numero * numero;

// Arrow functions com validação
bool validarNome(String nome) => nome.isNotEmpty && nome.length >= 2;
bool validarEmail(String email) => email.contains('@') && email.contains('.');

// Arrow functions matemáticas
int maximo(int a, int b) => a > b ? a : b;
double areaCirculo(double raio) => 3.14159 * raio * raio;

// Arrow function com lógica mais complexa (mas ainda uma expressão)
String classificarIdade(int idade) => 
    idade < 13 ? 'Criança' :
    idade < 18 ? 'Adolescente' :
    idade < 60 ? 'Adulto' : 'Idoso';</code></pre>
                    </div>
                </div>
                <div class="example-explanation">
                    <p><strong>Explicação:</strong></p>
                    <ul>
                        <li><code>=></code> substitui <code>{ return ... }</code> para funções de uma expressão</li>
                        <li>Arrow functions são ideais para operações simples e diretas</li>
                        <li><code>where()</code>, <code>map()</code>, <code>reduce()</code> são métodos que aceitam funções como parâmetro</li>
                        <li>Operador ternário <code>?:</code> funciona bem com arrow functions</li>
                        <li>Código fica mais limpo e conciso</li>
                    </ul>
                    <p><strong>Experimente:</strong> Converta algumas arrow functions de volta para a sintaxe tradicional e compare.</p>
                </div>
            </div>
        </section>

        <section class="content-section">
            <h2>6. Closures</h2>
            <p><strong>Closures</strong> são funções que "capturam" variáveis do escopo onde foram criadas. É como uma mochila - a função carrega consigo as variáveis que precisa, mesmo quando usada em outro lugar.</p>

            <div class="example">
                <h3>Exemplo 6 — Closures</h3>
                <div class="dartpad-container">
                    <div class="dartpad-header">
                        <span>DartPad - Closures</span>
                        <div class="dartpad-actions">
                            <button class="run-button"><i class="fas fa-play"></i> Executar</button>
                            <button class="copy-button"><i class="fas fa-copy"></i> Copiar</button>
                        </div>
                    </div>
                    <div class="code-block">
                        <pre><code>void main() {
  // Criando contadores independentes
  var contador1 = criarContador();
  var contador2 = criarContador();
  
  print('Contador 1: ${contador1()}'); // 1
  print('Contador 1: ${contador1()}'); // 2
  print('Contador 2: ${contador2()}'); // 1 (independente!)
  print('Contador 1: ${contador1()}'); // 3
  
  print('---');
  
  // Multiplicador personalizável
  var dobrar = criarMultiplicador(2);
  var triplicar = criarMultiplicador(3);
  
  print('Dobrar 5: ${dobrar(5)}');
  print('Triplicar 4: ${triplicar(4)}');
  
  print('---');
  
  // Sistema de configuração
  var configuracao = criarConfigurador();
  configuracao('host', 'localhost');
  configuracao('porta', '8080');
  configuracao('debug', 'true');
  
  var obterConfig = configuracao('', ''); // Função para obter configurações
  print('Host: ${obterConfig('host')}');
  print('Porta: ${obterConfig('porta')}');
  
  print('---');
  
  // Validador customizável
  var validarIdade = criarValidador(18, 'Deve ser maior de idade');
  var validarNota = criarValidador(7.0, 'Nota mínima é 7.0');
  
  print(validarIdade(20)); // null (válido)
  print(validarIdade(16)); // Mensagem de erro
  print(validarNota(8.5)); // null (válido)
  print(validarNota(5.0)); // Mensagem de erro
}

// Closure que mantém estado de um contador
Function criarContador() {
  int contador = 0; // Variável capturada
  
  return () {
    contador++; // Modifica a variável capturada
    return contador;
  };
}

// Closure que cria multiplicadores personalizados
Function(int) criarMultiplicador(int fator) {
  return (int numero) => numero * fator; // 'fator' é capturado
}

// Closure para sistema de configuração simples
Function criarConfigurador() {
  Map<String, String> configuracoes = {}; // Estado capturado
  
  return (String chave, String valor) {
    if (chave.isEmpty) {
      // Retorna função para obter configurações
      return (String key) => configuracoes[key];
    } else {
      // Define configuração
      configuracoes[chave] = valor;
      print('Configurado: $chave = $valor');
    }
  };
}

// Closure para validação personalizável
Function criarValidador(num minimo, String mensagem) {
  return (num valor) {
    if (valor >= minimo) {
      return null; // Válido
    } else {
      return mensagem; // Inválido
    }
  };
}</code></pre>
                    </div>
                </div>
                <div class="example-explanation">
                    <p><strong>Explicação:</strong></p>
                    <ul>
                        <li>Closures "capturam" variáveis do escopo externo (<code>contador</code>, <code>fator</code>, <code>configuracoes</code>)</li>
                        <li>Cada closure mantém sua própria cópia das variáveis capturadas</li>
                        <li>As variáveis capturadas persistem mesmo após a função externa terminar</li>
                        <li>Closures são úteis para criar funções especializadas e manter estado privado</li>
                        <li><code>Function</code> é o tipo base para qualquer função em Dart</li>
                    </ul>
                    <p><strong>Experimente:</strong> Crie múltiplos contadores e veja como cada um mantém seu estado independente.</p>
                </div>
            </div>
        </section>

        <section class="content-section">
            <h2>7. Funções de Alta Ordem</h2>
            <p><strong>Funções de alta ordem</strong> (higher-order functions) são funções que recebem outras funções como parâmetros ou retornam funções. É como ter um assistente que pode aprender novos truques.</p>

            <div class="example">
                <h3>Exemplo 7 — Funções de Alta Ordem</h3>
                <div class="dartpad-container">
                    <div class="dartpad-header">
                        <span>DartPad - Funções de Alta Ordem</span>
                        <div class="dartpad-actions">
                            <button class="run-button"><i class="fas fa-play"></i> Executar</button>
                            <button class="copy-button"><i class="fas fa-copy"></i> Copiar</button>
                        </div>
                    </div>
                    <div class="code-block">
                        <pre><code>void main() {
  // Lista para demonstrações
  List<int> numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  
  // Aplicando diferentes transformações
  print('Números originais: $numeros');
  print('Dobrados: ${aplicarTransformacao(numeros, dobrar)}');
  print('Ao quadrado: ${aplicarTransformacao(numeros, (n) => n * n)}');
  print('Negativos: ${aplicarTransformacao(numeros, (n) => -n)}');
  
  print('---');
  
  // Filtrando com diferentes critérios
  print('Pares: ${filtrarLista(numeros, ehPar)}');
  print('Maiores que 5: ${filtrarLista(numeros, (n) => n > 5)}');
  print('Múltiplos de 3: ${filtrarLista(numeros, (n) => n % 3 == 0)}');
  
  print('---');
  
  // Operações de redução
  print('Soma: ${reduzirLista(numeros, (a, b) => a + b)}');
  print('Produto: ${reduzirLista(numeros, (a, b) => a * b)}');
  print('Máximo: ${reduzirLista(numeros, (a, b) => a > b ? a : b)}');
  
  print('---');
  
  // Pipeline de operações
  var resultado = processar(
    numeros,
    filtro: (n) => n % 2 == 0,
    transformacao: (n) => n * n,
    reducao: (a, b) => a + b
  );
  print('Pipeline (pares -> quadrados -> soma): $resultado');
  
  print('---');
  
  // Sistema de cache com função personalizada
  var fibonacci = comCache(calcularFibonacci);
  
  print('Fibonacci(10): ${fibonacci(10)}');
  print('Fibonacci(10) novamente: ${fibonacci(10)}'); // Vem do cache
  print('Fibonacci(15): ${fibonacci(15)}');
}

// Função que recebe outra função como parâmetro
List<int> aplicarTransformacao(List<int> lista, int Function(int) transformacao) {
  return lista.map(transformacao).toList();
}

// Função para filtrar com critério personalizado
List<int> filtrarLista(List<int> lista, bool Function(int) criterio) {
  return lista.where(criterio).toList();
}

// Função para reduzir lista com operação personalizada
int reduzirLista(List<int> lista, int Function(int, int) operacao) {
  return lista.reduce(operacao);
}

// Pipeline de processamento
int processar(
  List<int> lista, {
  required bool Function(int) filtro,
  required int Function(int) transformacao,
  required int Function(int, int) reducao
}) {
  return lista
    .where(filtro)
    .map(transformacao)
    .reduce(reducao);
}

// Função que retorna função (decorator pattern)
Function comCache(Function funcaoOriginal) {
  Map<dynamic, dynamic> cache = {};
  
  return (dynamic parametro) {
    if (cache.containsKey(parametro)) {
      print('Cache hit para $parametro');
      return cache[parametro];
    }
    
    var resultado = funcaoOriginal(parametro);
    cache[parametro] = resultado;
    print('Calculado e armazenado no cache: $parametro = $resultado');
    return resultado;
  };
}

// Funções auxiliares
int dobrar(int n) => n * 2;
bool ehPar(int n) => n % 2 == 0;

// Função custosa para demonstrar cache
int calcularFibonacci(int n) {
  if (n <= 1) return n;
  return calcularFibonacci(n - 1) + calcularFibonacci(n - 2);
}</code></pre>
                    </div>
                </div>
                <div class="example-explanation">
                    <p><strong>Explicação:</strong></p>
                    <ul>
                        <li><code>int Function(int)</code> especifica o tipo de uma função que recebe int e retorna int</li>
                        <li>Higher-order functions permitem código mais flexível e reutilizável</li>
                        <li><code>map()</code>, <code>where()</code>, <code>reduce()</code> são exemplos nativos do Dart</li>
                        <li>Cache com closures demonstra padrões avançados de programação</li>
                        <li>Pipeline permite encadear operações de forma elegante</li>
                    </ul>
                    <p><strong>Experimente:</strong> Crie suas próprias funções de transformação e teste no pipeline.</p>
                </div>
            </div>
        </section>

        <section class="content-section">
            <h2>8. Boas Práticas</h2>
            
            <div class="best-practices">
                <div class="practice-do">
                    <h3>✅ Nomes Descritivos e Consistência:</h3>
                    <div class="dartpad-container">
                        <div class="dartpad-header">
                            <span>DartPad - Boas Práticas</span>
                            <div class="dartpad-actions">
                                <button class="run-button"><i class="fas fa-play"></i> Executar</button>
                                <button class="copy-button"><i class="fas fa-copy"></i> Copiar</button>
                            </div>
                        </div>
                        <div class="code-block">
                            <pre><code>void main() {
  // ✅ BOM: nomes descritivos
  double preco = calcularPrecoComDesconto(100.0, 0.1);
  bool dadosValidos = validarFormularioUsuario('João', 'joao@email.com', 25);
  
  // ❌ EVITAR: nomes genéricos
  // double calc(double x, double y) { ... }
  // bool check(String a, String b, int c) { ... }
  
  print('Preço com desconto: R\$ ${preco.toStringAsFixed(2)}');
  print('Dados válidos: $dadosValidos');
}

double calcularPrecoComDesconto(double precoOriginal, double percentualDesconto) {
  if (percentualDesconto < 0 || percentualDesconto > 1) {
    throw ArgumentError('Desconto deve estar entre 0 e 1');
  }
  return precoOriginal * (1 - percentualDesconto);
}

bool validarFormularioUsuario(String nome, String email, int idade) {
  return nome.isNotEmpty && 
         email.contains('@') && 
         idade >= 0 && idade <= 120;
}</code></pre>
                        </div>
                    </div>
                </div>
                
                <div class="practice-avoid">
                    <h3>❌ Tratamento de Erros e Validações:</h3>
                    <div class="dartpad-container">
                        <div class="dartpad-header">
                            <span>DartPad - Tratamento de Erros</span>
                            <div class="dartpad-actions">
                                <button class="run-button"><i class="fas fa-play"></i> Executar</button>
                                <button class="copy-button"><i class="fas fa-copy"></i> Copiar</button>
                            </div>
                        </div>
                        <div class="code-block">
                            <pre><code>void main() {
  try {
    print(dividirSeguro(10, 2));
    print(dividirSeguro(10, 0)); // Vai lançar exceção
  } catch (e) {
    print('Erro capturado: $e');
  }
  
  // Exemplo com validação de entrada
  print(processarIdade(25));
  print(processarIdade(-5)); // Retorna mensagem de erro
}

double dividirSeguro(double dividendo, double divisor) {
  if (divisor == 0) {
    throw ArgumentError('Divisão por zero não é permitida');
  }
  return dividendo / divisor;
}

String processarIdade(int idade) {
  // ✅ BOM: validação no início
  if (idade < 0 || idade > 150) {
    return 'Idade inválida';
  }
  
  // Lógica principal depois da validação
  if (idade < 18) {
    return 'Menor de idade';
  } else if (idade < 65) {
    return 'Adulto';
  } else {
    return 'Terceira idade';
  }
}</code></pre>
                        </div>
                    </div>
                </div>
            </div>

            <h3>Dicas Importantes:</h3>
            <ol class="warning-list">
                <li><strong>Funções pequenas e focadas</strong> - cada função deve fazer apenas uma coisa</li>
                <li><strong>Validar parâmetros</strong> - sempre verifique se os dados de entrada são válidos</li>
                <li><strong>Usar null-safety</strong> - aproveite os recursos do Dart 3.0+</li>
                <li><strong>Documentar funções complexas</strong> - use comentários para explicar lógicas não óbvias</li>
                <li><strong>Consistência nos nomes</strong> - use convenções claras (verbos para ações, substantivos para dados)</li>
            </ol>
        </section>

        <section class="content-section">
            <h2>9. Casos de Uso Reais</h2>
            
            <div class="real-cases">
                <div class="case">
                    <h3>1. Validação de Formulários Web</h3>
                    <p>Em aplicações web e mobile, funções são essenciais para validar dados do usuário:</p>
                    <div class="code-block">
                        <pre><code>// Validadores reutilizáveis para formulários
bool validarEmail(String email) => 
    email.contains('@') && email.contains('.') && email.length > 5;

bool validarSenha(String senha) => 
    senha.length >= 8 && senha.contains(RegExp(r'[0-9]'));

String? validarCampoObrigatorio(String? valor, String nomeCampo) {
  if (valor == null || valor.trim().isEmpty) {
    return '$nomeCampo é obrigatório';
  }
  return null;
}</code></pre>
                    </div>
                </div>
                
                <div class="case">
                    <h3>2. Processamento de APIs e Dados</h3>
                    <p>Funções de alta ordem são muito usadas para processar respostas de APIs:</p>
                    <div class="code-block">
                        <pre><code>// Simulando processamento de dados de uma API
List<Map<String, dynamic>> processarUsuarios(
  List<Map<String, dynamic>> usuarios,
  bool Function(Map<String, dynamic>) filtro,
  Map<String, dynamic> Function(Map<String, dynamic>) transformacao
) {
  return usuarios
      .where(filtro)
      .map(transformacao)
      .toList();
}</code></pre>
                    </div>
                </div>
                
                <div class="case">
                    <h3>3. Configuração de Aplicações</h3>
                    <p>Closures são ideais para sistemas de configuração:</p>
                    <div class="code-block">
                        <pre><code>// Sistema de configuração para apps
Function criarGerenciadorConfig() {
  Map<String, dynamic> config = {
    'apiUrl': 'https://api.exemplo.com',
    'timeout': 5000,
    'debug': false
  };
  
  return (String chave, [dynamic valor]) {
    if (valor != null) {
      config[chave] = valor;
    }
    return config[chave];
  };
}</code></pre>
                    </div>
                </div>
            </div>
        </section>

        <section class="content-section">
            <h2>10. Exercícios Práticos</h2>
            
            <div class="exercises">
                <div class="exercise">
                    <h3>Exercício 1: Calculadora de IMC</h3>
                    <p>Crie uma função que calcule o IMC (Índice de Massa Corporal) e retorne uma classificação. Use parâmetros nomeados e validação de entrada.</p>
                </div>
                
                <div class="exercise">
                    <h3>Exercício 2: Calculadora com Arrow Functions</h3>
                    <p>Implemente uma calculadora usando arrow functions para as operações básicas (+, -, *, /).</p>
                </div>
                
                <div class="exercise">
                    <h3>Exercício 3: Sistema de Desconto</h3>
                    <p>Crie um sistema de desconto usando closures que permita configurar diferentes tipos de desconto (percentual, valor fixo, progressivo).</p>
                </div>
                
                <div class="exercise">
                    <h3>Exercício 4: Processador de Produtos</h3>
                    <p>Desenvolva uma função de alta ordem que processe uma lista de produtos, aplicando filtros e transformações personalizáveis.</p>
                </div>
                
                <div class="exercise">
                    <h3>Exercício 5: Sistema de Cache</h3>
                    <p>Implemente um sistema de cache simples usando closures que funcione com qualquer tipo de função.</p>
                </div>
            </div>
            
            <div class="toggle-solutions">
                <button class="solution-toggle">Ver Gabarito dos Exercícios</button>
            </div>
            
            <div class="solutions" style="display: none;">
                <div class="solution">
                    <h3>Resposta 1: Calculadora de IMC</h3>
                    <div class="dartpad-container">
                        <div class="dartpad-header">
                            <span>DartPad - Resposta Exercício 1</span>
                            <div class="dartpad-actions">
                                <button class="run-button"><i class="fas fa-play"></i> Executar</button>
                                <button class="copy-button"><i class="fas fa-copy"></i> Copiar</button>
                            </div>
                        </div>
                        <div class="code-block">
                            <pre><code>void main() {
  // Testando casos válidos
  print('IMC 18.4: ${classificarIMC(peso: 60, altura: 1.80)}');
  print('IMC 22.2: ${classificarIMC(peso: 80, altura: 1.90)}');
  print('IMC 27.8: ${classificarIMC(peso: 90, altura: 1.80)}');
  print('IMC 35.0: ${classificarIMC(peso: 100, altura: 1.70)}');
  
  // Testando validação de entrada
  try {
    print(classificarIMC(peso: -5, altura: 1.70));
  } catch (e) {
    print('Erro: $e');
  }
  
  try {
    print(classificarIMC(peso: 70, altura: 0));
  } catch (e) {
    print('Erro: $e');
  }
}

// Função que calcula IMC e retorna classificação
String classificarIMC({required double peso, required double altura}) {
  // Validação de entrada
  if (peso <= 0) throw ArgumentError('Peso deve ser maior que zero');
  if (altura <= 0) throw ArgumentError('Altura deve ser maior que zero');
  
  // Cálculo do IMC
  double imc = calcularIMC(peso: peso, altura: altura);
  
  // Classificação baseada no IMC
  if (imc < 18.5) return 'Abaixo do peso (IMC: ${imc.toStringAsFixed(1)})';
  if (imc < 25) return 'Peso normal (IMC: ${imc.toStringAsFixed(1)})';
  if (imc < 30) return 'Sobrepeso (IMC: ${imc.toStringAsFixed(1)})';
  if (imc < 35) return 'Obesidade grau I (IMC: ${imc.toStringAsFixed(1)})';
  if (imc < 40) return 'Obesidade grau II (IMC: ${imc.toStringAsFixed(1)})';
  return 'Obesidade grau III (IMC: ${imc.toStringAsFixed(1)})';
}

// Arrow function para cálculo do IMC
double calcularIMC({required double peso, required double altura}) => peso / (altura * altura);</code></pre>
                        </div>
                    </div>
                </div>
                
                <div class="solution">
                    <h3>Resposta 2: Calculadora com Arrow Functions</h3>
                    <div class="dartpad-container">
                        <div class="dartpad-header">
                            <span>DartPad - Resposta Exercício 2</span>
                            <div class="dartpad-actions">
                                <button class="run-button"><i class="fas fa-play"></i> Executar</button>
                                <button class="copy-button"><i class="fas fa-copy"></i> Copiar</button>
                            </div>
                        </div>
                        <div class="code-block">
                            <pre><code>void main() {
  // Testando operações básicas
  print('5 + 3 = ${somar(5, 3)}');
  print('10 - 4 = ${subtrair(10, 4)}');
  print('6 * 7 = ${multiplicar(6, 7)}');
  print('15 / 3 = ${dividir(15, 3)}');
  
  // Testando divisão por zero
  try {
    print('10 / 0 = ${dividir(10, 0)}');
  } catch (e) {
    print('Erro: $e');
  }
  
  // Usando a calculadora com operação personalizada
  double resultado = calcular(10, 5, multiplicar);
  print('Calculadora: 10 * 5 = $resultado');
}

// Arrow functions para operações básicas
double somar(double a, double b) => a + b;
double subtrair(double a, double b) => a - b;
double multiplicar(double a, double b) => a * b;
double dividir(double a, double b) => b != 0 ? a / b : throw ArgumentError('Divisão por zero');

// Função que recebe operação como parâmetro
double calcular(double a, double b, double Function(double, double) operacao) => operacao(a, b);</code></pre>
                        </div>
                    </div>
                </div>
                
                <div class="solution">
                    <h3>Resposta 3: Sistema de Desconto</h3>
                    <div class="dartpad-container">
                        <div class="dartpad-header">
                            <span>DartPad - Resposta Exercício 3</span>
                            <div class="dartpad-actions">
                                <button class="run-button"><i class="fas fa-play"></i> Executar</button>
                                <button class="copy-button"><i class="fas fa-copy"></i> Copiar</button>
                            </div>
                        </div>
                        <div class="code-block">
                            <pre><code>void main() {
  // Criando diferentes tipos de desconto
  var descontoPercentual = criarDesconto('percentual', 0.1); // 10%
  var descontoFixo = criarDesconto('fixo', 50.0); // R$ 50
  var descontoProgressivo = criarDesconto('progressivo', 100.0); // A cada R$ 100, 5% desconto
  
  double preco = 500.0;
  
  print('Preço original: R\$ ${preco.toStringAsFixed(2)}');
  print('Com desconto percentual: R\$ ${descontoPercentual(preco).toStringAsFixed(2)}');
  print('Com desconto fixo: R\$ ${descontoFixo(preco).toStringAsFixed(2)}');
  print('Com desconto progressivo: R\$ ${descontoProgressivo(preco).toStringAsFixed(2)}');
}

Function(double) criarDesconto(String tipo, double valor) {
  switch (tipo) {
    case 'percentual':
      return (double preco) => preco * (1 - valor); // valor é percentual (0.1 = 10%)
    
    case 'fixo':
      return (double preco) => preco > valor ? preco - valor : 0.0; // desconto fixo
    
    case 'progressivo':
      return (double preco) {
        int faixas = (preco / valor).floor(); // quantas faixas de R$ valor
        double percentualDesconto = faixas * 0.05; // 5% por faixa
        percentualDesconto = percentualDesconto > 0.3 ? 0.3 : percentualDesconto; // máximo 30%
        return preco * (1 - percentualDesconto);
      };
    
    default:
      return (double preco) => preco; // sem desconto
  }
}</code></pre>
                        </div>
                    </div>
                </div>
                
                <div class="solution">
                    <h3>Resposta 4: Processador de Produtos</h3>
                    <div class="dartpad-container">
                        <div class="dartpad-header">
                            <span>DartPad - Resposta Exercício 4</span>
                            <div class="dartpad-actions">
                                <button class="run-button"><i class="fas fa-play"></i> Executar</button>
                                <button class="copy-button"><i class="fas fa-copy"></i> Copiar</button>
                            </div>
                        </div>
                        <div class="code-block">
                            <pre><code>void main() {
  // Lista de produtos simulada
  List<Map<String, dynamic>> produtos = [
    {'nome': 'Notebook', 'preco': 2500.0, 'categoria': 'eletrônicos', 'estoque': 5},
    {'nome': 'Mouse', 'preco': 50.0, 'categoria': 'eletrônicos', 'estoque': 20},
    {'nome': 'Livro Dart', 'preco': 80.0, 'categoria': 'livros', 'estoque': 0},
    {'nome': 'Cadeira', 'preco': 300.0, 'categoria': 'móveis', 'estoque': 3},
    {'nome': 'Mesa', 'preco': 600.0, 'categoria': 'móveis', 'estoque': 2},
  ];
  
  // Processando produtos: eletrônicos em estoque com desconto
  var produtosProcessados = processarProdutos(
    produtos,
    filtro: (produto) => 
        produto['categoria'] == 'eletrônicos' && produto['estoque'] > 0,
    transformacao: (produto) => {
      ...produto,
      'precoPromocional': produto['preco'] * 0.9, // 10% desconto
      'disponivel': true
    }
  );
  
  print('Produtos eletrônicos em promoção:');
  for (var produto in produtosProcessados) {
    print('${produto['nome']}: R\$ ${produto['preco']} → R\$ ${produto['precoPromocional'].toStringAsFixed(2)}');
  }
  
  print('\n---\n');
  
  // Processando produtos: móveis caros com frete grátis
  var moveisCaros = processarProdutos(
    produtos,
    filtro: (produto) => 
        produto['categoria'] == 'móveis' && produto['preco'] > 400,
    transformacao: (produto) => {
      ...produto,
      'freteGratis': true,
      'prazoEntrega': '5-7 dias úteis'
    }
  );
  
  print('Móveis com frete grátis:');
  for (var produto in moveisCaros) {
    print('${produto['nome']}: R\$ ${produto['preco']} - Frete grátis!');
  }
}

List<Map<String, dynamic>> processarProdutos(
  List<Map<String, dynamic>> produtos, {
  required bool Function(Map<String, dynamic>) filtro,
  required Map<String, dynamic> Function(Map<String, dynamic>) transformacao
}) {
  return produtos
      .where(filtro)
      .map(transformacao)
      .toList();
}</code></pre>
                        </div>
                    </div>
                </div>
                
                <div class="solution">
                    <h3>Resposta 5: Sistema de Cache</h3>
                    <div class="dartpad-container">
                        <div class="dartpad-header">
                            <span>DartPad - Resposta Exercício 5</span>
                            <div class="dartpad-actions">
                                <button class="run-button"><i class="fas fa-play"></i> Executar</button>
                                <button class="copy-button"><i class="fas fa-copy"></i> Copiar</button>
                            </div>
                        </div>
                        <div class="code-block">
                            <pre><code>void main() {
  // Cache para função matemática
  var fibonacciComCache = criarCache(fibonacci);
  
  print('=== Testando Cache com Fibonacci ===');
  print('fibonacci(10): ${fibonacciComCache(10)}');
  print('fibonacci(10) novamente: ${fibonacciComCache(10)}'); // Cache hit
  print('fibonacci(12): ${fibonacciComCache(12)}');
  
  print('\n=== Testando Cache com String ===');
  var processarTextoComCache = criarCache(processarTexto);
  
  print(processarTextoComCache('olá mundo'));
  print(processarTextoComCache('olá mundo')); // Cache hit
  print(processarTextoComCache('dart é incrível'));
  
  print('\n=== Testando Cache com Lista ===');
  var somarListaComCache = criarCache(somarLista);
  
  print('Soma [1,2,3,4,5]: ${somarListaComCache([1,2,3,4,5])}');
  print('Soma [1,2,3,4,5] novamente: ${somarListaComCache([1,2,3,4,5])}'); // Cache hit
}

// Sistema de cache universal
Function criarCache(Function funcaoOriginal) {
  Map<String, dynamic> cache = {};
  
  return (dynamic parametro) {
    String chave = parametro.toString();
    
    if (cache.containsKey(chave)) {
      print('💾 Cache HIT para: $chave');
      return cache[chave];
    }
    
    print('⚡ Calculando: $chave');
    var resultado = funcaoOriginal(parametro);
    cache[chave] = resultado;
    return resultado;
  };
}

// Funções para testar o cache
int fibonacci(int n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}

String processarTexto(String texto) {
  // Simulando processamento custoso
  return texto.split(' ')
      .map((palavra) => palavra[0].toUpperCase() + palavra.substring(1).toLowerCase())
      .join(' ');
}

int somarLista(List<int> numeros) {
  return numeros.reduce((a, b) => a + b);
}</code></pre>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section class="content-section">
            <h2>11. Resumo</h2>
            <div class="summary-points">
                <h3>10 pontos-chave para memorizar:</h3>
                <ol>
                    <li><strong>Funções básicas</strong> - Use <code>tipo nomeFunc(parametros) { return valor; }</code> para estrutura básica</li>
                    <li><strong>Parâmetros posicionais</strong> - A ordem importa: <code>func(a, b, c)</code></li>
                    <li><strong>Parâmetros nomeados</strong> - Use <code>{required tipo nome}</code> para clareza: <code>func(nome: valor)</code></li>
                    <li><strong>Parâmetros opcionais</strong> - <code>[tipo? nome]</code> posicionais ou <code>{tipo nome = padrão}</code> nomeados</li>
                    <li><strong>Arrow functions</strong> - Use <code>=></code> para funções simples de uma expressão</li>
                    <li><strong>Closures</strong> - Funções que "capturam" variáveis do escopo externo</li>
                    <li><strong>Higher-order functions</strong> - Funções que recebem ou retornam outras funções</li>
                    <li><strong>Validação</strong> - Sempre valide parâmetros de entrada com <code>throw ArgumentError()</code></li>
                    <li><strong>Null-safety</strong> - Use <code>tipo?</code> para valores opcionais e <code>required</code> para obrigatórios</li>
                    <li><strong>Nomes descritivos</strong> - Use verbos para ações e seja específico na nomenclatura</li>
                </ol>
            </div>
        </section>

        <section class="content-section">
            <h2>12. Glossário</h2>
            <div class="glossary">
                <div class="glossary-item">
                    <strong>Arrow Function</strong>: Sintaxe concisa (<code>=></code>) para funções de uma única expressão.
                </div>
                <div class="glossary-item">
                    <strong>Closure</strong>: Função que captura e mantém acesso a variáveis do escopo onde foi definida.
                </div>
                <div class="glossary-item">
                    <strong>Função</strong>: Bloco de código reutilizável que executa uma tarefa específica.
                </div>
                <div class="glossary-item">
                    <strong>Higher-Order Function</strong>: Função que recebe outras funções como parâmetros ou retorna funções.
                </div>
                <div class="glossary-item">
                    <strong>Null-Safety</strong>: Sistema do Dart que previne erros de referência nula em tempo de compilação.
                </div>
                <div class="glossary-item">
                    <strong>Parâmetro Nomeado</strong>: Parâmetro identificado pelo nome na chamada da função, não pela posição.
                </div>
                <div class="glossary-item">
                    <strong>Parâmetro Opcional</strong>: Parâmetro que pode ser omitido na chamada da função.
                </div>
                <div class="glossary-item">
                    <strong>Parâmetro Posicional</strong>: Parâmetro identificado pela posição na chamada da função.
                </div>
                <div class="glossary-item">
                    <strong>Required</strong>: Palavra-chave que torna um parâmetro nomeado obrigatório.
                </div>
                <div class="glossary-item">
                    <strong>Return</strong>: Palavra-chave que especifica o valor retornado por uma função.
                </div>
            </div>
        </section>

        <section class="content-section">
            <h2>13. Referências</h2>
            <div class="references">
                <ol>
                    <li><a href="https://dart.dev/language/functions" target="_blank">Dart Language Tour - Functions</a></li>
                    <li><a href="https://dart.dev/effective-dart/design#functions" target="_blank">Effective Dart - Function Signatures</a></li>
                    <li><a href="https://api.dart.dev/stable/" target="_blank">Dart SDK Documentation</a></li>
                    <li><a href="https://dartpad.dev" target="_blank">DartPad Online</a></li>
                </ol>
            </div>
            
            <div class="study-tip">
                <p><strong>Preparação recomendada:</strong></p>
                <ul class="feature-list">
                    <li>Pratique todos os exercícios deste capítulo</li>
                    <li>Experimente criar suas próprias funções no DartPad</li>
                    <li>Tente combinar diferentes tipos de parâmetros em uma única função</li>
                    <li>Explore o uso de closures para manter estado em pequenos projetos</li>
                </ul>
            </div>
        </section>
    </div>
    <script src="assets/js/script.js" type="module"></script>
</body>
</html>
